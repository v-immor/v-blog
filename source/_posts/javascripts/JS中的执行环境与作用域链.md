---
title: JS 中的执行环境与作用域链
date: 2022-04-20 21:22
categories:
    - [JavaScript]
tags:
  - JS 基础
---

## 执行环境的概念
- **执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。**
- **每一个执行环境都有一个与之关联的变量对象，环境中所有定义的变量和函数都保存在这个变量中。**
   - 这个变量我们无法通过代码访问到，但解释器可以使用到它。
   - 在全局执行环境中这个变量可以近似认为是 window/global，但仅限于不使用关键字、 var 和 function 定义的变量或函数。
- **当执行环境中的所有代码都执行完毕后，环境会被销毁，保存在其中的所有变量和函数定义也会被销毁。**
   - 全局执行环境直到应用程序退出才会销毁(关闭网页/浏览器)
- **每一个函数都有自己的执行环境，当执行一个函数时，该函数的执行环境会被推入到一个环境栈中，在函数执行完毕后将该函数的执行环境弹出，并把控制权返还给之前的执行环境。**
## 作用域链的概念
> JS 没有块级作用域，但不代表没有作用域。
> 当代码在一个执行环境中执行时，会创建变量对象的一个作用域链(scope chain)。
> 作用域链的用途就是保证对执行环境有权访问的所有变量和函数的有序访问。

- 作用域链的前端始终是当前执行环境的变量对象。如：window
- 如果在一个函数执行环境中，则会将其活动对象作为变量对象，并且在初始时只有一个变量 arguments。
- 作用域链中的下一个变量对象则是上一个执行环境的变量对象，以此类推知道全局执行环境的变量对象，全局执行环境的变量对象始终是作用域链的最后一个对象。
- 标识符解析就是沿着作用域链一级一级搜索标识符的过程，且搜索过程始终从作用域链的前端开始逐级回溯。
## 执行环境与作用域链

- 内部环境可以通过作用域链访问到所有的外部执行环境，但是外部的执行环境不能够访问内部执行环境中的任何变量和函数。
   - 可以理解为环境可以向上搜索，但不能向下搜索。
   - 当在作用域链中搜索到标识符后即会停止向上搜索，所以如果存在同名变量时，只会取到最近执行环境中的同名变量。
   - 由作用域链的搜索方式可以得知，局部变量访问速度要比全局变量要快一馁馁。当然，因为 JS 引擎在标识符搜索查询方面做的很好，所以这点速度一般可以忽略不记。
- 使用 var 关键字声明的变量会自动添加到最近的执行环境中，如果没有使用 var 来声明变量则会自动添加到全局执行环境中。
   - 如果先使用后声明变量，则可能会导致意外的结果。所以在严格模式下，初始化未声明的变量将会报错。
```javascript
// 浏览器环境下

// 使用 var 声明，自动添加到全局执行环境的变量对象 window 上
var a = 1

function A() {
  // 没有使用 var 声明，则自动添加到 window 下，A 函数执行完不会被销毁
  b = 2
  // 使用 var 声明，自动添加到 A 的执行环境的变量对象上。A 函数执行完即会销毁
  var c = 3
  
  // 从 A 函数执行环境的变量对象中搜索，没有找到，接着向上搜索到全局执行环境中 a 
  console.log(a) // 1
}

window.c // undefined

// 不能够向下搜索找到 A 中的 c
c // r is not defined

A()

window.a // 1
window.b // 2
window.c // undefined
// A 函数执行完立即销毁执行环境及其内所有的变量与函数。
c // r is not defined

```
## JS 为什么没有块级作用域？
> 这是 JS 设计时的因素，因为 JS 的代码块不会像其他语言一样形成自己的作用域，只会依托于最近的执行环境的变量对象。
> 可以简单的把函数执行环境作为块级作用域的表现。
> 在 ES6 之后，通过 let/const 声明的变量将具有块级作用域的表现。

```javascript
if(true) {
  var a = 1
}
// 在代码块外部也能访问变量 a
console.log(a) // 1

function A() {
  if (true) {
    var b = 2
  }
  // 在函数执行环境中也是一样的，代码块外部也能访问变量 b
  console.log(b) // 2
}

A()

// 因为 b 在 A 函数的执行环境中，所以无法在全局环境中访问，并且 A 函数执行完后也会进行销毁
console.log(b) //Uncaught ReferenceError: b is not defined

for (var i = 0; i < 10; i++) {
  // 如果有异步执行，则由 JS 的执行机制导致 i 将是变量后的 i
  // async fn(i) ==> fn(10)
}

console.log(i) // 10
```

- try-catch 中的 catch 语句以及 with 语句有延长作用域的现象。
## ES6 后的有趣现象
> 关于 const、let、var、暂时性死区等 ES6 相关内容 -- [ES6 后的 JS 世界](https://www.yuque.com/visionking/sxnyaw/eckzta)

```javascript
const a = 1

var b = 2

function A() {
  // 使用 const/let 声明的变量不会添加到 window 中
  console.log(window.a) // undefined
  console.log(a) // 1
  //var 声明的全局变量会自动添加到 window 对象中
  console.log(window.b) // 2
}

A()
```
```javascript
const a = { b: 1 }
const b = 1

b = 2 // Uncaught TypeError: Assignment to constant variable.

// const/let 锁定的是栈内存中的值，而不是堆中的值
const a.b = 2 // a = { b: 2 }


```
