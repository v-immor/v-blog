---
title: React Fiber 是什么？
date: 2022-04-07 10:32
categories:
- [JavaScript, React]
tags:
- React
- 原理
---

## 从 React 的架构演进来看 React 为视图渲染做了哪些优化
**React 渲染页面主要可以看成两个阶段：**

- **调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。**
- **渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上。**
### React 15 架构
在 React 15 及之前的版本中，渲染机制主要分成两层：

- Reconciler（协调器）：也就是属于调度阶段，主要负责找出变化的组件；
- Renderer（渲染器）：也就是属于渲染阶段，主要负责将变化的组件渲染到页面上；

**在 React15 及之前的版本中，Reconciler 采用递归的方式创建虚拟 DOM ，递归过程是不能中断的，如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了 16.666ms（在 60hz 屏幕下浏览器刷新一帧的时间），用户交互就会卡顿。**
**React 15 及之前的版本中的 Reconciler 也称为 Stack Reconciler；**
### React 16 架构
为了解决之前的版本中 Reconciler 因递归无法中断，同步更新的线程占用过长时间导致用户交互掉帧的问题，React16 将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟 DOM 数据结构已经无法满足需要。所以 React 团队才会花费两年多的时间去将虚拟 DOM 演进为 Fiber，Stack Reconciler 重构为 Fiber Reconciler。
React 16 带来了 Fiber，也进一步带来了 Concurrent Mode（并发模式）虽然 Concurrent Mode 一直推迟到 React 18 才正式推入生产环境。
相比之前的两层架构，React 16 则分成了三层：

- Scheduler（调度器）：属于调度阶段，负责协调任务的优先级，高优先级的任务先进入 Reconciler。
- Reconciler（协调器）：属于调度阶段，主要负责找出变化的组件。
   - 与之前版本不同的是更新工作从递归变成了可以中断的循环过程。Reconciler 内部采用了 Fiber 的架构设计。
- Renderer（渲染器）：也就是属于渲染阶段，主要负责将变化的组件渲染到页面上；
### React 17 架构
前文有提到过，React 16 虽然实现了底层虚拟 DOM 的重构，让异步更新可实现，但是并发更新的问题也随之而来，主要还在于 React16 的 expirationTimes 模型只能区分是否 >=expirationTimes 决定节点是否更新。React17 的 lane 模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。
> Lane 用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是 Lane 所要解决的问题。

所以 React 17 的版本更像是一个过渡版本，所做的工作主要为 React 18 做铺垫，为 Concurrent Mode 的正式推出做好准备。
### React 18 架构
> 最新正式版，延后整理。

## 什么是 Fiber?
> 部分摘抄于：
> [这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.cn/post/6844903975112671239)
> [React Fiber 架构](https://zhuanlan.zhihu.com/p/37095662) -- 司徒正美

**Fiber 的英文含义是“纤维”，它是比线程（Thread）更细的线，比线程（Thread）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（Cooperative）编程模型（协程），帮助开发者用一种【既模块化又协作化】的方式来编排代码。**
**Fiber 也不是一个新玩意，最早的时候是在微软的 DOS 操作系统。**
微软 DOS 是一个单任务操作系统, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. invalid s在《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》 的回答中将其称为: '一种压根没有任务调度的“残疾”操作系统'。在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。
**为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行。**
JavaScript 也是单线程运行的，在浏览器环境中需要负责 JS 代码的解析和执行、绘制、事件处理、静态资源加载和处理，
> 这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript执行 两者是互斥的。另外异步 I/O 操作底层实际上可能是多线程的在驱动。

**它只是一个单线程的脚本语言，同一时间只能做一件事情，这个和 DOS 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个憨批任务长期霸占 CPU，排在后面的任务就无法执行，浏览器会呈现卡死的状态，这样的用户体验就会非常差。**
对于“前端框架”来说，解决这种问题有三个方向：

1. 优化每个任务，让它有多快就多快。挤压 CPU 运算量。
2. 快速响应用户，让用户觉得够快，不能阻塞用户的交互。
3. 尝试 Worker 多线程。

Vue 选择的是第 1 种, 因为对于Vue来说，使用模板让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新；而 React 选择了第 2 种，更快速地响应用户交互，将用户看不到的任务优先级降低执行；第 3 种 Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。
**所以 React 是怎么优化的？** 
为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率，同时兼顾任务执行效率。
**在 React 中，Fiber 架构就是 React 16 为了让 React 渲染的过程可以被中断（主动让出机制），可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。**
**fiber 则是 Fiber 架构中的基础数据结构/执行单元，也可以说是在 React Fiber 架构中的 Virtual DOM。**
## 为什么有 React Fiber 而没有 Vue Fiber?
> [https://juejin.cn/post/7077545184807878692](https://juejin.cn/post/7077545184807878692#heading-7)

前文讲述了 Fiber 架构的厉害之处，属于系统级别的架构设计。但为什么没有 Vue Fiber? 是 Vue 团队不够优秀，还是没有考虑到？

- 从架构设计就注定 React 和 Vue 的不同，关注点自然也不同。
   - 架构开发模式不同：
      - React 架构属于完全运行时（纯 JS），编译时难以判断可优化项，主要靠的运行时的计算来提升性能；
      - Vue 使用模板语法开发，可以在编译阶段对已确定的模板做出优化。
   - 响应式架构实现不同：
      - React 主要通过 setState 来更新状态再驱动视图更新，完全遵循 immutable（不可变）数据源的理念。
      - Vue 则通过双向绑定的响应式原理（数据劫持）监听变量，已达到直接修改变量即可驱动视图更新。
      - React 的组件渲染是比较消耗性能的，因为 React 难以做到精准更新，当父组件状态更新了，所有的子组件会跟着一起渲染（可以通过 memo / shouldUpdateComponent 优化）
> - React 的 Fiber 架构目前看到的结果更多的是为了将渲染工作进行时间切片处理，将之前版本的缺陷做修补，随后带来的异步更新和并发模式更像是 Fiber 架构带来的添头。
> - Fiber 这种数据结构使得节点可以回溯到其父节点，只要保留下中断的节点索引，就可以恢复之前的工作进度；
> - Vue 本身基于数据劫持的双向绑定，加上 Vue Diff 双向遍历优化，自然就不需要在运行时考虑更多的工作。

