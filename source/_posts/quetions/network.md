---
title: 网络
date: '2023-02-24 02:13:13'
quiz: true
hide: true
categories:
  - Quetions
tags:
  - 面试
abbrlink: 50daec4
---

## 网络基础

0. 介绍一下 `七层网络模型` 和 `TCP/IP 四层概念模型` {.quiz .fill}

   > - 七层网络模型
   >   `应用层` -> `表示层` -> `会话层` -> `传输层` -> `网络层` -> `数据链路层` -> `物理层`
   > - TCP/IP 概念模型
   >   `应用层` -> `传输层` -> `网络层` -> `数据链路层`
   > - 各层的代表协议
   >   应用层：**HTTP、FTP、SMTP** -> 为网络应用提供服务
   >   表示层：**Telnet、SNMP** -> 数据格式化、加解密
   >   会话层：**SMTP、DNS** -> 建立/维护/管理会话连接
   >   传输层：**TCP、UDP** -> 建立/维护/管理端到端的连接
   >   网络层：**IP、ICMP、ARP** -> IP 寻址、路由选择
   >   数据链路层：**PPP、PDN** -> 控制网络层和物理层之间的通讯
   >   物理层：**IEEE 802.1A** -> 比特率传输协议

1. `HTTP` 是什么？ {.quiz .fill}

   > - `HTTP` 是为了让客户端能够理解和呈现服务端发送的超文本内容，基于 `TCP/IP` 协议的应用层协议`超文本传输协议`。
   > - `HTTP` 具有`无状态`、`明文传输`、`报文灵活可扩展`、`可靠传输`等特点。
   > - `HTTP` 有一些缺陷：
   >
   >   1. `明文传输`的特点导致`数据传输的安全性欠缺`；
   >   2. 当使用 `HTTP/1` 时，一个 **TCP 连接** 同时只能处理一条请求，当前请求耗时过长会导致`队头堵塞`的问题；
   >   3. 在需要保存上下文信息时，`无状态`的特性会让网络开销增加；

2. `HTTP` 的组成部分有哪些？它的报文结构是怎样的？ {.quiz .fill}

   > - `请求报文`的组成部分 -> `状态行` + `请求头` + `消息主体`
   > - `响应报文`的组成部分 -> `状态行` + `响应头` + `响应正文`
   > - `报文结构`
   >   > 起始行 + 头部 + 空行 + 实体
   >   > 请求报文的起始行： `Method` + `Path` + `Version`
   >   > 响应报文的起始行： `Version` + `Status` + `Status Content`

3. `HTTP` 各个版本（1.0、1.1、2.0、3.0）的区别 {.quiz .fill}

   > - HTTP/1.0:
   >   **特点：**
   >   1. 引入 `if-Modified-since` 和 `expires` 作为缓存；
   >   2. 引入了 `POST` 和 `HEAD` 请求；
   >   3. 引入了长连接（keep-alive），可以有序的发起多个请求，但新的请求需要等待上一个请求响应才会发起，所以默认是关闭的；
   > - HTTP/1.1:
   >   **特点：**
   >   1. 默认开启长连接，引入了`管道机制`可在一个 TCP 连接中同时发出多个请求，但响应依旧是有序响应，所以会有`队头阻塞`的问题；
   >   2. 新增了请求方法：`PUT`、`DELETE`、`PATCH`、`OPTIONS`;
   >   3. 通过 `Range` 属性实现断点续传；
   >   4. 新增了缓存机制的失效控制字段：`E-tag`、`if-Match`、`if-None-Match`
   > - HTTP/2.0
   >   **特点：**
   >   1. 引入了`二进制分帧`来处理 header 和数据；
   >   2. 对 header 进行压缩，解决头部偏重的问题；
   >   3. `多路复用`，可以在一个 TCP 连接里，同时发起多个请求，并且可以不需要要有序响应，解决了`队头阻塞`的问题；
   >   4. `服务器推送`，服务器可以主动推送资源给客服端；
   >   5. `请求优先级`，可以设置数据帧的优先级，让服务端优先处理响应；
   > - HTTP/3.0（QUIC）
   >   **特点：**
   >   1. 使用 UDP 替换 TCP 建立连接；
   >   2. 使用了 `TLS1.3` 保证通讯的安全；

4. `HTTP` 有哪些请求方法？ {.quiz .fill}

   > `GET`、`POST`、`PUT`、`DELETE`、`OPTIONS`、`HEAD`、`CONNECT`、`PATCH`、`TRACE`

5. `GET` 和 `POST` 的区别 {.quiz .fill}

   > 1. `GET` 会被浏览器主动缓存下来，`POST` 不会。
   > 2. `GET` 的参数默认通过 URL 传参，并且会进行 `URL` 编码，`POST` 还可以在 `Body` 中进行传参，body 传参没有编码限制。
   > 3. `GET` 常用于获取数据，请求是`幂等`的，`POST` 常用于数据操作，默认没有`幂等性`
   > 4. `GET` 请求是一次性将报文都发送出去，`POST` 会先把 `header` 部分发出去，如果服务端响应了 100 状态才会把 `body` 部分发送出去。

6. `HTTP` 有哪些状态码？ {.quiz .fill}

   > - 1xx： `100` -> 服务端已收到请求，请继续发送后续请求；
   > - 2xx： `200` -> 成功响应请求，响应报文中会含有 body 部分；`204` -> 成功响应请求，但没有 body；`206` -> 响应成功，但返回内容仅是一部分，常用于分块下载、断点续传。
   > - 3xx： `301` -> 资源永久重定向到新地址；`302` -> 资源暂时重定向到新地址；`304` -> 资源未修改，重定向到缓存地址(`协商缓存`)
   > - 4xx： `400` -> 请求报文有错误；`401` -> 没有权限访问该资源；`403` -> 没有权限访问该资源，但资源是存在的；`404` -> 请求的资源不存在；
   > - 5xx：`500` -> 笼统的服务端错误，没有具体指明；`501` -> 客服端请求的功能还不支持；`502` -> 网关挂了，服务可能是正常的；`503` -> 服务器正忙，无法响应；
   > - 更多...

7. `HTTP/2` 的`多路复用`和 `HTTP/1.1` 的 `keep-alive` 的区别 {.quiz .fill}

   > 1. `多路复用` 指的是一个 TCP 连接下可以同时发起多个请求，并且不需要有序响应，不会阻塞请求的响应；
   > 2. `keep-alive` 仅是让 TCP 不断开，虽然可以同时发起多个请求，但是请求的响应会有序，会造成阻塞；

8. `HTTPS` 是什么 {.quiz .fill}

   > - `HTTPS` 是基于 `HTTP` 协议上套的一层 `TLS` 协议，用于服务器的身份认证，让`HTTP`更加安全。
   > - `HTTPS` 主要解决了`服务器的身份认证`、`明文传输`等问题。
   > - `HTTPS` 具有以下特点：
   >   1. 可以让内容加密，避免中间服务器查看;
   >   2. 通过 `HTTPS` 证书，验证用户访问的是否正确的服务器，避免被第三方 `DNS` 劫持到其他服务器；
   > - `TLS` 采用的是混合加密方式，先使用`非对称加密`方式建立起通信连接，通过`对称加密`的方式进行消息加密

9. `HTTPS` 的握手过程 {.quiz .fill}

   > - 握手可以分为五个阶段
   > 1. 由客户端传递`协议版本号`、一个`随机数`、`支持的加密方法`；
   > 2. 由服务端确认使用何种`加密方法`，并将`数字证书`、服务端产生的`随机数`传递给客户端；
   > 3. 客户端确认证书有效后，生成一个`新的随机数`、并使用数字证书中的`公钥`对这个随机数进行加密后传递给服务端；
   > 4. 服务端使用私钥解密获得随机数，用三个随机数进行计算生成本次会话所需的`会话秘钥`，将协商的加密方法和秘钥发送给客户端、并通知握手结束通知；
   > 5. 进入会话阶段，通过`会话秘钥`加密全部对话过程；

10. `HTTPS` 的握手过程中，客户端如何验证证书的合法性 {.quiz .fill}

11. `TLS` 是什么？ {.quiz .fill}

12. 介绍一下 `HTTPS` 的中间人攻击 {.quiz .fill}

13. `TCP` 和 `UDP` 的区别？ {.quiz .fill}

14. `TCP` 的三次握手和四次挥手 {.quiz .fill}

15. A、B 机器正常连接后，B 机器突然重启，问 A 此时 处于 TCP 什么状态？ {.quiz}

    - SYN_SENT {.correct}
    - SYN_RCVD
    - ESTABLISHED
    - FIN_WAIT1
    - CLOSE_WAIT
      {.options}

16. `HTTP/3` 为什么基于 UDP 实现？如何解决 UDP 的弊端 {.quiz .fill}

17. `HTTP 状态码` 有哪些以及对应的含义 {.quiz .fill}

18. `DNS` 的解析原理 {.quiz .fill}

19. `Cookie` 是什么？ {.quiz .fill}

20. `Cookie` 和 `Session`，以及和 `Storage` 的区别？ {.quiz .fill}

21. `跨域` 是什么？如何解决跨域 {.quiz .fill}

22. 什么是 `CSRF` 攻击，如何防范？ {.quiz .fill}

23. 什么是`预请求`？ {.quiz .fill}

## 浏览器

1. 描述从输入 URL 到页面显示的过程 {.quiz .fill}

2. 浏览器有几个进程？ 分别的作用是？ {.quiz .fill}

   > 1. 渲染进程 n
   >
   > - GUI 渲染线程：负责渲染页面(`解析 HTML` -> `构建 DOM 树` -> `CSSOM 树构建` -> `合成 Render 树` -> 布局、绘制)。`GUI 渲染进程` 和 `JS 引擎线程`是互斥的，JS 代码执行会阻塞页面的渲染；
   > - JS 引擎线程：等待任务队列的进入，负责解析 JS 代码，JS 的执行；与 `GUI 渲染线程` 互斥，会在异步宏任务之间询问是否需要调用 `GUI 渲染线程`；
   > - 计时器线程：`setTimeout` 和 `setInterval` 计时的线程，计时结束后会将回调任务通过`事件触发线程`放入任务队列，等待 `JS 引擎线程`调用；
   > - 事件触发线程：负责维护事件任务队列；
   > - HTTP 请求线程：负责发起请求，若有回调任务则会通过`事件触发线程`加入到任务队列中，等待执行；
   >
   > 2. GPU 进程 1
   > 3. 网络进程 1
   > 4. 插件进程 n
   > 5. 浏览器进程 1
   >
   > - 浏览器的界面显示，管理页签、管理进程，将页面内容写入内存，渲染图像，文件存储；

3. 浏览器的渲染进程里，有什么线程？ {.quiz .fill}

4. 浏览器一帧内做了什么 {.quiz .fill}

   > - 主线程的一帧：
   > - -> `Input Event` -> `JS Task` -> `Begin Frame` -> `RAF` -> `Layout` -> `Paint` -> `RIC` ->
   > - `Input Event`：用户输入事件
   > - `JS Task`：同步代码

5. 描述一下浏览器的事件机制 {.quiz .fill}

6. 浏览器存储数据的方式有哪些 {.quiz .fill}

7. service worker 是什么 {.quiz fill}

8. `Web Worker` 是什么？ {.quiz .fill}

9. `MessageChannel` 和 `window.postMessage` {.quiz .fill}

   > - MessageChannel 是主线程异步执行，Window.postMessage 是 web Worker 进程

10. 如何进行跨页签通信？ {.quiz .fill}

    > - `Web Worker`: window.postMessage
    > - `MessageChannel`
    > - `webSocket`：借助服务器
